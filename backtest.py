import pandas as pd
import warnings
import numpy as np
import os,json
from datetime import timedelta
import backtest_config as btc
import time
from config import u2_permutation_dict_65_etf
import period_functions as pf
from tqdm import tqdm
# Now, 'data' contains the JSON data as a Python data structure
# You can access and manipulate 'data' as needed

cwd = os.getcwd()

# with open('all_selected_stocks_2.json') as f: # file name
#     final_stocks_data = json.load(f)

percent_return_dict={}

num_stocks= 8

sharpe_ratios=[]
calmar_ratios=[]
annualized_returns = []
STOCKS_DF = pd.read_csv('./stock_data/US_Market_totalClose.csv', index_col='Date')
STOCKS_DF = STOCKS_DF[0:6206]

# # historical_data = pd.read_csv("final_774_stocks.csv")## path for historical data of stocks
# with open("permutations_u1.json") as f: # file name
#     portfolio_permutations = json.load(f)

def csv_export(portfolio_number, backtesting_dict, uni):
    data_list = [{'Month': month, 'Date': date, 'Investment': investment}
                for month, data in backtesting_dict.items()
                for date, investment in zip(data['date'], data['investment_value'])]

    # Create a DataFrame from the list of dictionaries
    df = pd.DataFrame(data_list)

    # Convert the 'Date' column to datetime
    df['Date'] = pd.to_datetime(df['Date'])

    # Find the first date for each month
    first_dates = df.groupby('Month')['Date'].min().reset_index()

    # Generate missing dates with a value of 1000
    missing_dates = []
    for month, first_date in zip(first_dates['Month'], first_dates['Date']):
        current_date = first_date
        while current_date < df[df['Month'] == month]['Date'].max():
            current_date += timedelta(days=1)
            if current_date not in df[df['Month'] == month]['Date'].values:
                missing_dates.append({'Month': month, 'Date': current_date, 'Investment': 1000.0})

    # Create a DataFrame for missing dates
    missing_df = pd.DataFrame(missing_dates)

    # Concatenate the original DataFrame and the missing dates DataFrame
    df = pd.concat([df, missing_df], ignore_index=True)

    # Pivot the DataFrame to have 12 columns for each month
    df = df.pivot(index='Date', columns='Month', values='Investment').reset_index()

    # Sort the DataFrame by 'Date'
    df.sort_values('Date', inplace=True)

    # Reset the index
    df.reset_index(drop=True, inplace=True)

    # Fill missing values with 1000
    df.fillna(1000.0, inplace=True)
    df2 = df[~(df.iloc[:, 1:] == 1000).all(axis=1)]

    # Reset the index
    df2.reset_index(drop=True, inplace=True)
    exclude_months = ['all_oct', 'all_sep']

    # Loop through each month's column and repeat the second-row value in the last row
    for month in df2.columns[1:]:
        if month not in exclude_months:
            print(month)
            df2.loc[df2.index[-1], month] = df2.loc[df2.index[-2], month]

            print(df2.iloc[-1][month])

    df2['Final Investment'] = df2.iloc[:, 1:].sum(axis=1)

    df2.iloc[:, 1:] = df2.iloc[:, 1:].replace(1000, method='ffill')
    df2.to_csv(f"../portfolio_data/{uni} {portfolio_number} Portfolio Data.csv")

def generate_historical_data_df(start_date,end_date):
    """Generates historical DataFrame for Stocks

    Args:
        start_date (Str): Start Date for simulation
        end_date (Str): End date

    Returns:
        DataFrame: Stocks Historical Data
    """

    STOCKS_DF.index = pd.to_datetime(STOCKS_DF.index)
    STOCKS_DF.index = STOCKS_DF.index.strftime('%Y-%m-%d')
    STOCKS_DF.index = pd.to_datetime(STOCKS_DF.index)
    try:
        final_df=STOCKS_DF.loc[start_date:end_date]
    except:
        print("Problem with loading historical data")
    return final_df


def generate_results_universe(num_permutations:int, uni = "u2"):
    """This code will run simulation on 500 portfolios selected according to the given filter/close type and universe.
        The files generated via this code will be used for creating plots. 

    Args:
        universe (str): Pass universe For ex: "all_5_years","3_periods"
        filter (str): Pass the filter name ex: "52_week" or "N/A" (in case of simulating only the universe)
        quarters (list): Pass the quarters list generated by get_quarters_list()
        close_type (str): Pass "adj_close" or "close"
        num_stocks (int): Pass the number of random stocks.
        num_permutations(int): Pass the number of portfolios to be simulated.
        nifty_symbol(str): Currently "UTINIFTETF.BO"
    """

    print(os.getcwd())
    historical_data = pd.read_csv('./stock_data/US_Market_totalClose.csv', index_col='Date')

    for j in tqdm(range(num_permutations)):
        st = time.time()
        # print(f"....... Starting {j+1} iteration of {num_permutations}, choosing portfolio... {j} ,")
        initial_investment = 12000

        investment = initial_investment/12
        investment_filter={}

        capital_dict = {
        'all_aug': investment,
        'all_sep': investment,
        'all_oct': investment,
        'all_nov': investment,
        'all_dec': investment,
        'all_jan': investment,
        'all_feb': investment,
        'all_mar': investment,
        'all_apr': investment,
        'all_may': investment,
        'all_jun': investment,
        'all_jul': investment,
    }
        annualised_dict = {
        'all_aug': None,
        'all_sep': None,
        'all_oct': None,
        'all_nov': None,
        'all_dec': None,
        'all_jan': None,
        'all_feb': None,
        'all_mar': None,
        'all_apr': None,
        'all_may': None,
        'all_jun': None,
        'all_jul': None,
    }
        backtesting_dict = {
        'all_aug': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_sep': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_oct': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_nov': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_dec': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_jan': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_feb': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_mar': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_apr': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_may': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_jun': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
        'all_jul': {'date': None, 'investment_value': None, 'final_investment':None, 'initial_investment':investment,'annualised_return':None},
    }
        
        months_dict = btc.buying_periods_10y_14_23
        
        month_int = {
        'Jan' : '01',
        'Feb' : '02',
        'Mar' : '03',
        'Apr' : '04',
        'May' : '05',
        'Jun' : '06',
        'Jul' : '07',
        'Aug' : '08',
        'Sep' : '09',
        'Oct' : '10',
        'Nov' : '11',
        'Dec' : '12'
    }

        list_final_df = []

        weights_df = []
        warnings.filterwarnings('ignore')

        # Code to perform operations
        
                
        for month_name, month_list in months_dict.items():

            # Your code here, using 'key' as the current quarter type and 'quarters_list' as the list of quarters.
            date_list = []
            investment_list= []

            for month in month_list:
                
                    
                #print(month)
                selected_stocks = u2_permutation_dict_65_etf[month][j] # accessing the j th portfolio 
                
                
                
                year_ = month[-4:]
                month_ = month_int[month[:3]]
                start_date,end_date= pf.get_start_end_from_month(month,period=1)
                
                
                historical_data = generate_historical_data_df(start_date,end_date)
                historical_data.index = pd.to_datetime(historical_data.index)
                selected_stocks = [stock for stock in selected_stocks if stock in historical_data.columns]
                historical_data = historical_data[selected_stocks]
                
                # Equal Allocation 

                weights = {column: 1/len(historical_data.columns) for column in historical_data.columns}

                ############################################################

                weights_df.append(weights)
                # weights_value = {key: value * Q1s_final_capital for key, value in weights.items()}
                weights_value = {key: value * capital_dict[month_name] for key, value in weights.items()}
                cols = []

                ########### we will normalise the historical data and multiply it by investment value #######
                
                ## Add the column (w dynamic names) of each stock's investment.
                monthly_dict = {}
                for column in historical_data.columns: 
                    new_col = f'{column}_Portfolio'
                    historical_data[column] = historical_data[column].astype(float)
                    historical_data[new_col] = historical_data[column] / float(historical_data[column].iloc[0]) * weights_value[column]
                    monthly_dict[column]=round(historical_data[new_col].iloc[0],2)
                    cols.append(new_col)
                investment_filter[month]=monthly_dict

                #Final dataframe containing values of investment in each stock.
                final_df = historical_data[cols]

                ##logic to note the companies in a month and then save their investment.
                

                # print(final_df)
                final_df['Investment'] = final_df.sum(axis=1)
                list_final_df.append(final_df)
                try:
                    capital_dict[month_name] = final_df['Investment'].iloc[-1]
                    percent_return_dict[month] = (final_df['Investment'].iloc[-1]/final_df['Investment'].iloc[0]-1)*100
                
                    backtesting_dict[month_name]['final_investment'] = final_df['Investment'].iloc[-1]
                    end_quarter = month
                    backtesting_dict[month_name]['annualised_return'] = (((capital_dict[month_name]/ investment) ** (1/9.67)) - 1)*100 #annualized returns
                    investment_list.extend(final_df['Investment'].tolist())
                    date_list.extend(final_df.index.tolist())
                except:
                    print(f"Issue: {month}")
                    
                # except Exception as e: 
                #     print(e)
                #     print("Couldn't Complete Experiments from ",month)
            
            backtesting_dict[month_name]['date'] = date_list
            backtesting_dict[month_name]['investment_value'] = investment_list


        merged_df = pd.DataFrame()

        for i, df in enumerate(list_final_df):
            merged_df = pd.concat([merged_df, df])


        # years = end_date.year - 2018 + (end_date.month/12) - 0.5
        years = 9.75
        initial_capital = initial_investment
        #print("Initial Capital: ",initial_capital)
        # strategy_final_capital = Q2s_final_capital+Q3s_final_capital+Q4s_final_capital+ Q1s_final_capital
        strategy_final_capital = sum(capital_dict.values())

        #print("Final Capital: ",strategy_final_capital)

        annualized_returns_new= (((strategy_final_capital/ initial_capital) ** (1/9.67)) - 1) * 100 # annualized returns
        #print(time.time()-st," Seconds")
        # invest_df_path=f"../portfolio_data/{uni} {j} Portfolio Data.csv"
        # if os.path.exists(invest_df_path) == False:
        #     csv_export(j, backtesting_dict, uni)
        
        # invest_df = pd.read_csv(invest_df_path).set_index('Date')
        # invest_df.index = pd.to_datetime(invest_df.index)
        
        
        # investment_data = invest_df["Final Investment"]

        # first_date = invest_df.index[0].date()
        # last_date = invest_df.index[-1].date()
        # trading_days = np.busday_count(first_date, last_date)# change the date

        # cumulative_returns = (investment_data / investment_data.cummax()) - 1
        # cr_ex = (investment_data / investment_data.cummax())

        # drawdown = cumulative_returns.min()
        # max_drawdown = -drawdown 

        # returns = investment_data.pct_change()
        # risk_free_rate = 0.00
        # trading_days_yearly = trading_days/years
    
        # annualized_volatility = returns.std() * (trading_days_yearly ** 0.5)
        # downside_returns = returns.copy()

        # downside_returns[downside_returns > 0] = 0
        # downside_volatility = downside_returns.std() * (trading_days_yearly ** 0.5)

        # sharpe_ratio = round(((annualized_returns_new/100) - risk_free_rate) / annualized_volatility, 2)
        # # sortino_ratio = round(((annualized_returns_new/100)  - risk_free_rate) / downside_volatility, 2)
        # calmar_ratio = round((annualized_returns_new/100) / max_drawdown,2)

        # sharpe_ratios.append(sharpe_ratio)
        # calmar_ratios.append(calmar_ratio)
        annualized_returns.append(annualized_returns_new)
    # return sharpe_ratios, calmar_ratios, annualized_returns
    return annualized_returns


if __name__ == "__main__":
    returns = generate_results_universe(num_permutations = 500)
    print(returns)
    out_file = open('./Annual_Returns/annualized_returns-u2etf-65.json', "w") 
    json.dump(returns, out_file, indent=4)